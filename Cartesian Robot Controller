#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.executors import MultiThreadedExecutor
from rclpy.callback_groups import ReentrantCallbackGroup

from moveit_msgs.action import MoveGroup
from moveit_msgs.msg import (
    MotionPlanRequest,
    PlanningOptions,
    Constraints,
    PositionConstraint,
    OrientationConstraint
)
from geometry_msgs.msg import (
    PoseStamped,
    Pose,
    Point,
    Quaternion
)
from shape_msgs.msg import SolidPrimitive
from std_msgs.msg import Header
from sensor_msgs.msg import JointState

import math
from typing import Tuple, Optional, Dict, Any
from enum import Enum

class MoveResult(Enum):
    SUCCESS = "success"
    UNREACHABLE = "unreachable"
    COLLISION = "collision_detected"
    PLANNING_FAILED = "planning_failed"
    EXECUTION_FAILED = "execution_failed"
    TIMEOUT = "timeout"
    INVALID_POSE = "invalid_pose"

class CartesianRobotController(Node):
    """
    ROS2 Node for controlling UR3 robot using Cartesian coordinates via MoveIt
    """
    
    def __init__(self):
        super().__init__('cartesian_robot_controller')
        
        # Callback group for handling concurrent operations
        self.callback_group = ReentrantCallbackGroup()
        
        # MoveIt action client
        self.move_action_client = ActionClient(
            self,
            MoveGroup,
            '/move_action',
            callback_group=self.callback_group
        )
        
        # Robot configuration
        self.planning_group = "ur_manipulator"  # Default UR3 planning group
        self.base_frame = "base_link"
        self.end_effector_link = "tool0"
        
        # Planning parameters
        self.planning_time = 5.0  # seconds
        self.planning_attempts = 5
        self.velocity_scaling_factor = 0.1
        self.acceleration_scaling_factor = 0.1
        
        # Wait for MoveIt action server
        self.get_logger().info("Waiting for MoveIt action server...")
        self.move_action_client.wait_for_server()
        self.get_logger().info("MoveIt action server connected!")
        
    def create_pose_goal(self, x: float, y: float, z: float, 
                        qx: float = 0.0, qy: float = 1.0, qz: float = 0.0, qw: float = 0.0) -> PoseStamped:
        """
        Create a pose goal for the robot end-effector
        
        Args:
            x, y, z: Cartesian position in meters
            qx, qy, qz, qw: Quaternion orientation (default: pointing down)
        
        Returns:
            PoseStamped: Target pose for the end-effector
        """
        pose_goal = PoseStamped()
        pose_goal.header.frame_id = self.base_frame
        pose_goal.header.stamp = self.get_clock().now().to_msg()
        
        pose_goal.pose.position.x = float(x)
        pose_goal.pose.position.y = float(y)
        pose_goal.pose.position.z = float(z)
        
        pose_goal.pose.orientation.x = float(qx)
        pose_goal.pose.orientation.y = float(qy)
        pose_goal.pose.orientation.z = float(qz)
        pose_goal.pose.orientation.w = float(qw)
        
        return pose_goal
    
    def create_motion_plan_request(self, target_pose: PoseStamped) -> MotionPlanRequest:
        """
        Create a motion planning request for MoveIt
        
        Args:
            target_pose: Target pose for the end-effector
            
        Returns:
            MotionPlanRequest: Complete motion planning request
        """
        req = MotionPlanRequest()
        
        # Basic request setup
        req.workspace_parameters.min_corner.x = -1.0
        req.workspace_parameters.min_corner.y = -1.0
        req.workspace_parameters.min_corner.z = -1.0
        req.workspace_parameters.max_corner.x = 1.0
        req.workspace_parameters.max_corner.y = 1.0
        req.workspace_parameters.max_corner.z = 1.0
        req.workspace_parameters.header.frame_id = self.base_frame
        req.workspace_parameters.header.stamp = self.get_clock().now().to_msg()
        
        # Planning group
        req.group_name = self.planning_group
        
        # Planning options
        req.num_planning_attempts = self.planning_attempts
        req.allowed_planning_time = self.planning_time
        req.max_velocity_scaling_factor = self.velocity_scaling_factor
        req.max_acceleration_scaling_factor = self.acceleration_scaling_factor
        
        # Goal constraints
        constraints = Constraints()
        
        # Position constraint
        position_constraint = PositionConstraint()
        position_constraint.header = target_pose.header
        position_constraint.link_name = self.end_effector_link
        position_constraint.target_point_offset.x = 0.0
        position_constraint.target_point_offset.y = 0.0
        position_constraint.target_point_offset.z = 0.0
        
        # Define constraint region (small sphere around target)
        constraint_region = SolidPrimitive()
        constraint_region.type = SolidPrimitive.SPHERE
        constraint_region.dimensions = [0.01]  # 1cm tolerance
        
        position_constraint.constraint_region.primitives = [constraint_region]
        position_constraint.constraint_region.primitive_poses = [target_pose.pose]
        position_constraint.weight = 1.0
        
        # Orientation constraint
        orientation_constraint = OrientationConstraint()
        orientation_constraint.header = target_pose.header
        orientation_constraint.link_name = self.end_effector_link
        orientation_constraint.orientation = target_pose.pose.orientation
        orientation_constraint.absolute_x_axis_tolerance = 0.1
        orientation_constraint.absolute_y_axis_tolerance = 0.1
        orientation_constraint.absolute_z_axis_tolerance = 0.1
        orientation_constraint.weight = 1.0
        
        constraints.position_constraints = [position_constraint]
        constraints.orientation_constraints = [orientation_constraint]
        req.goal_constraints = [constraints]
        
        return req
    
    async def move_to_pose(self, x: float, y: float, z: float,
                          qx: float = 0.0, qy: float = 1.0, qz: float = 0.0, qw: float = 0.0,
                          execute: bool = True) -> Tuple[MoveResult, Dict[str, Any]]:
        """
        Move robot end-effector to specified Cartesian pose
        
        Args:
            x, y, z: Target position in meters (base_link frame)
            qx, qy, qz, qw: Target orientation as quaternion
            execute: Whether to execute the motion (False for planning only)
            
        Returns:
            Tuple[MoveResult, Dict]: Result status and additional information
        """
        # Validate input
        if not self._validate_pose(x, y, z, qx, qy, qz, qw):
            return MoveResult.INVALID_POSE, {"error": "Invalid pose parameters"}
        
        # Create pose goal
        target_pose = self.create_pose_goal(x, y, z, qx, qy, qz, qw)
        
        # Create motion plan request
        motion_plan_request = self.create_motion_plan_request(target_pose)
        
        # Create MoveGroup goal
        goal = MoveGroup.Goal()
        goal.request = motion_plan_request
        
        # Planning options
        planning_options = PlanningOptions()
        planning_options.plan_only = not execute
        planning_options.look_around = False
        planning_options.look_around_attempts = 0
        planning_options.max_safe_execution_cost = 0.0
        planning_options.replan = True
        planning_options.replan_attempts = 3
        planning_options.replan_delay = 2.0
        
        goal.planning_options = planning_options
        
        try:
            # Send goal and wait for result
            self.get_logger().info(f"Planning motion to pose: [{x:.3f}, {y:.3f}, {z:.3f}]")
            
            future = self.move_action_client.send_goal_async(goal)
            rclpy.spin_until_future_complete(self, future)
            
            goal_handle = future.result()
            if not goal_handle.accepted:
                return MoveResult.PLANNING_FAILED, {"error": "Goal rejected by action server"}
            
            # Wait for result
            result_future = goal_handle.get_result_async()
            rclpy.spin_until_future_complete(self, result_future)
            
            result = result_future.result().result
            
            # Parse result
            return self._parse_move_result(result, execute)
            
        except Exception as e:
            self.get_logger().error(f"Error during motion planning/execution: {str(e)}")
            return MoveResult.PLANNING_FAILED, {"error": str(e)}
    
    def _validate_pose(self, x: float, y: float, z: float, 
                      qx: float, qy: float, qz: float, qw: float) -> bool:
        """
        Validate pose parameters
        
        Args:
            x, y, z: Position coordinates
            qx, qy, qz, qw: Quaternion components
            
        Returns:
            bool: True if pose is valid
        """
        # Check for NaN or infinite values
        pose_values = [x, y, z, qx, qy, qz, qw]
        if any(not math.isfinite(val) for val in pose_values):
            return False
        
        # Check quaternion normalization (approximately)
        quat_norm = math.sqrt(qx*qx + qy*qy + qz*qz + qw*qw)
        if abs(quat_norm - 1.0) > 0.1:
            self.get_logger().warn(f"Quaternion not normalized: {quat_norm}")
            return False
        
        # Basic workspace limits for UR3 (approximate)
        if not (-0.85 <= x <= 0.85 and -0.85 <= y <= 0.85 and 0.0 <= z <= 1.2):
            self.get_logger().warn(f"Position outside typical UR3 workspace: [{x}, {y}, {z}]")
            # Don't return False - let MoveIt handle detailed workspace validation
        
        return True
    
    def _parse_move_result(self, result, executed: bool) -> Tuple[MoveResult, Dict[str, Any]]:
        """
        Parse MoveIt result and return appropriate status
        
        Args:
            result: MoveGroup action result
            executed: Whether motion was executed or just planned
            
        Returns:
            Tuple[MoveResult, Dict]: Parsed result and information
        """
        info = {
            "planning_time": result.planning_time,
            "executed": executed
        }
        
        # Check planning result
        if result.error_code.val == result.error_code.SUCCESS:
            if executed:
                self.get_logger().info("Motion executed successfully!")
                return MoveResult.SUCCESS, info
            else:
                self.get_logger().info("Motion planned successfully!")
                return MoveResult.SUCCESS, info
        
        # Handle different error codes
        error_code = result.error_code.val
        
        if error_code == result.error_code.PLANNING_FAILED:
            return MoveResult.PLANNING_FAILED, {**info, "error": "Planning failed"}
        elif error_code == result.error_code.INVALID_MOTION_PLAN:
            return MoveResult.PLANNING_FAILED, {**info, "error": "Invalid motion plan"}
        elif error_code == result.error_code.MOTION_PLAN_INVALIDATED_BY_ENVIRONMENT_CHANGE:
            return MoveResult.COLLISION, {**info, "error": "Environment change detected"}
        elif error_code == result.error_code.CONTROL_FAILED:
            return MoveResult.EXECUTION_FAILED, {**info, "error": "Control failed"}
        elif error_code == result.error_code.UNABLE_TO_AQUIRE_SENSOR_DATA:
            return MoveResult.PLANNING_FAILED, {**info, "error": "Unable to acquire sensor data"}
        elif error_code == result.error_code.TIMED_OUT:
            return MoveResult.TIMEOUT, {**info, "error": "Planning timed out"}
        elif error_code == result.error_code.PREEMPTED:
            return MoveResult.PLANNING_FAILED, {**info, "error": "Planning preempted"}
        else:
            return MoveResult.PLANNING_FAILED, {**info, "error": f"Unknown error code: {error_code}"}

# Example usage functions
async def example_moves(controller: CartesianRobotController):
    """
    Example function demonstrating various moves
    """
    # Example poses for UR3 (adjust based on your setup)
    test_poses = [
        (0.3, 0.0, 0.5, 0.0, 1.0, 0.0, 0.0),  # Forward position
        (0.0, 0.3, 0.4, 0.0, 1.0, 0.0, 0.0),  # Side position
        (0.2, 0.2, 0.6, 0.0, 1.0, 0.0, 0.0),  # Diagonal position
    ]
    
    for i, (x, y, z, qx, qy, qz, qw) in enumerate(test_poses):
        print(f"\n--- Move {i+1}: Moving to [{x}, {y}, {z}] ---")
        
        # First, just plan the motion
        result, info = await controller.move_to_pose(x, y, z, qx, qy, qz, qw, execute=False)
        print(f"Planning result: {result.value}")
        print(f"Planning time: {info.get('planning_time', 0):.3f} seconds")
        
        if result == MoveResult.SUCCESS:
            # If planning succeeded, execute the motion
            result, info = await controller.move_to_pose(x, y, z, qx, qy, qz, qw, execute=True)
            print(f"Execution result: {result.value}")
        else:
            print(f"Skipping execution due to planning failure: {info.get('error', 'Unknown error')}")

def main():
    rclpy.init()
    
    # Create controller
    controller = CartesianRobotController()
    
    # Use MultiThreadedExecutor for handling callbacks
    executor = MultiThreadedExecutor()
    executor.add_node(controller)
    
    try:
        # Run example moves
        import asyncio
        asyncio.run(example_moves(controller))
        
        # Keep node running for further commands
        print("\nController ready for commands...")
        rclpy.spin(controller)
        
    except KeyboardInterrupt:
        print("Shutting down...")
    finally:
        controller.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()